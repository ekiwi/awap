#include <stdint.h>
#include "enums.hpp"	// generated by communication tool

struct Slice
{
	uint8_t* ptr;
	size_t length;
}


%% for module in modules
namespace {{ module.name }}
{

%% for service in module.services
struct {{ service.name }}
{

%% for message in service.messages
struct {{ message.name }}
{
	%% for field in message.fields
		{{ field.cpp.type }} {{ field.name }} : {{ field.size }};
	%% endfor
};
%% endfor

enum class MessageId : uint8_t
{
%% for message in service.messages
	{{ message.name }} = {{ message.id }},
%% endfor
}

static constexpr size_t MessageIdSize = {{ service.message_id_size }}

static inline bool parseMessage(MessageId id, const Slice& data);

} // struct {{ service.name }}
%% endfor

} // namespace {{ module.name }}
%% endfor


template<class ServiceType>
class MessageIdReader
{
private:
	static constexpr size_t Bits = MessageIdReader::MessageIdSize;
	static_assert(Bits <= 8, "Bits may not be greater 8");
	static constexpr uint8_t Shift = 8-Bits;
	static constexpr uint8_t Mask = ((1<<Bits)-1) << Shift;
public:
	static inline auto read(const uint8_t& data) -> ServiceType::MessageId{
		return (data & Mask) >> Shift;
	}
}

static inline bool parseMessage(Service service, const Slice& data)
{
	// make sure, that there is enough space for a message id
	if(data.length < 1) {
		return false;
	}

	switch(Service) {
%% for service in services
	case {{ service.name }}:
		{{ service.name }}.parseMessage(MessageIdReader<{{ service.name }}>::read(data.ptr[0], data);
		break;
%% endfor
	default:
		// Error!
		break;
	}
}
