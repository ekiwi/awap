package de.rwth_aachen.awap.service.remote;

import de.rwth_aachen.awap.Agent;
import de.rwth_aachen.awap.Message;
import de.rwth_aachen.awap.BroadcastMessage;
import de.rwth_aachen.awap.RemoteAgent;
import de.rwth_aachen.awap.RemoteService;
import de.rwth_aachen.awap.ServiceFilter;
import de.rwth_aachen.awap.ServiceProperty;
import de.rwth_aachen.awap.messages.{{ service.name }}.*;

public final class {{service.name}} extends RemoteService {
	public {{service.name}}(Agent parent, RemoteAgent remoteAgent, byte remoteServiceId) {
		super(parent, remoteAgent, remoteServiceId);
	}

	public static class Type
	{
		Agent parent;
		ServiceFilter filter = new ServiceFilter({{ service.id }});
		public Type(Agent parent) {
			this.parent = parent;
		}

		// add properties to describe type
%% for prop in service.properties
		public Type {{ prop.name | camelCase}}({{ prop.java.type }}... values) {
			for({{ prop.java.type }} value : values) {
				this.filter.properties.add(new ServiceProperty({{ prop.id }}, value));
			}
			return this;
		}
%% endfor

		// these methods can be used to broadcast messages to a certain type of sensors
%% for msg in service.messages
	%% if msg.rx
		public void send({{ msg.name }} msg) {
			this.parent.node.send(new BroadcastMessage(msg, this.filter));
		}
	%% endif
%% endfor
	}

	// message handlers
%% for msg in service.messages
	%# Remember, that tx and rx are reversed, now that we are the client!
	%% if msg.rx
	public void send({{ msg.name }} msg) {
		msg.serviceId = {{ service.id }};
		msg.remoteAgent = this.remoteAgent;
		this.parent.node.send(msg);
	}
	%% endif
%% endfor
}

