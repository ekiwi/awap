/**
 * message_parser.cpp
 *
 * Copyright (c) 2015 Kevin Laeufer <kevin.laeufer@rwth-aachen.de>
 *
 * This file is part of awap.
 */


#include "message_parser.hpp"
#include <hpp/ostfriesentee.hpp>
#include <jlib_awap-common.hpp>
#include "messages.hpp"

namespace awap {
namespace generated {
namespace MessageParserFactory {

static ostfriesentee::Infusion awapCommonInfusion{nullptr};
void setAwapCommonInfusion(ostfriesentee::Infusion& inf) {
	awapCommonInfusion = inf;
	dj_mem_addSafePointer((void**)&awapCommonInfusion);
}

%% for service in services
	%% for msg in service.messages
		%% if msg.fields|length == 0
ref_t {{service.name}}::createJava_{{ msg.name }}(const Slice<const uint8_t> /*input*/)
		%% else
ref_t {{service.name}}::createJava_{{ msg.name }}(const Slice<const uint8_t> input)
		%% endif
{
	using Message = ::awap::generated::message::{{ service.name }}::{{ msg.name }};
		%% if msg.fields|length == 0
	Message::JavaClass obj(awapCommonInfusion);
	// WARN: needs to be handed to java code before any java memory is allocated
	//       or else it will be garbage collected!
	return obj.getRef();
		%% else
	if(check(Message::Bytes <= input.length, Warning::MessageParserTooShort)) {
		// create java object
		Message::JavaClass obj(awapCommonInfusion);
		// this is safe, because we checked the length above
		auto java_struct = obj.getUnderlying();
		const auto data = input.data;
		// unmarshal
		{{ msg.cpp.unmarshal }}
		// WARN: needs to be handed to java code before any java memory is allocated
		//       or else it will be garbage collected!
		return obj.getRef();
	} else {
		return 0;	// error
	}
		%% endif
}

		%% if msg.fields|length == 0
size_t {{service.name}}::fromJava_{{ msg.name }}(ref_t /*obj*/, const Slice<uint8_t> output)
		%% else
size_t {{service.name}}::fromJava_{{ msg.name }}(ref_t obj, const Slice<uint8_t> output)
		%% endif
{
	using Message = ::awap::generated::message::{{ service.name }}::{{ msg.name }};
	if(check(Message::Bytes <= output.length, Warning::MessageParserOutputTooSmall)) {
		%% if msg.fields|length > 0
		auto java_data = static_cast<const Message::JavaClass::UnderlyingType*>(REF_TO_VOIDP(obj));
		%% endif
		// field aliases
		const auto id = Message::Id;
		%% for field in msg.fields
		const auto {{ field.name }} = java_data->{{ field.name }};
		%% endfor
		// marshal, this is safe, because we checked the length above
		auto data = output.data;
		{{ msg.cpp.marshal }}
		return Message::Bytes;
	} else {
		return 0;	// error, zero bytes written
	}
}

	%% endfor
%% endfor

} // namespace MessageParser
} // namespace generated
} // namespace awap
