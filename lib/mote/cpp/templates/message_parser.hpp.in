/**
 * message_parser.hpp
 *
 * Copyright (c) 2015 Kevin Laeufer <kevin.laeufer@rwth-aachen.de>
 *
 * This file is part of awap.
 */

#ifndef GENERATED_MESSAGE_PARSER_HPP
#define GENERATED_MESSAGE_PARSER_HPP

#include <message.hpp>
#include <util.hpp>

namespace awap {

struct MessageParser {
	using CreateJavaObjectFunctionPtr = ref_t (*)(Slice<uint8_t>);
	size_t bits = 0;
	CreateJavaObjectFunctionPtr createJava = nullptr;

	MessageParser(const size_t bits, const CreateJavaObjectFunctionPtr createJava)
		: bits(bits), createJava(createJava) {}
};


namespace generated {
namespace MessageParserFactory {

%% for service in services
class {{ service.name }} {
	static constexpr uint8_t MessageIdBits = {{ service.message_id_size }};
	static constexpr uint8_t MessageIdOffset = (8 - MessageIdBits);
	static constexpr uint8_t MessageIdMask = ((1 << MessageIdBits) - 1) << MessageIdOffset;

public:
	%% for msg in service.messages
	static ref_t createJava_{{ msg.name }}(const Slice<uint8_t> data);
	%% endfor

	static const MessageParser getMessageParser(const Slice<uint8_t> data) {
		Slice<uint8_t> input = data.sub(1);
		if(input.isEmpty()) return { 0, nullptr };	// Error
		const uint8_t messageId = (input.data[0] & MessageIdMask) >> MessageIdOffset;

		switch(messageId) {
	%% for msg in service.messages
		case {{ msg.id }}:	// {{ msg.name }}
			return { MessageIdBits + {{ msg.size}}, createJava_{{ msg.name }} };
	%% endfor
		default:
			return { 0, nullptr };
		}
	}

};
%% endfor

static const MessageParser getMessageParser(const ServiceTypeId serviceType, const Slice<uint8_t> data) {
	switch(serviceType) {
%% for service in services
	case {{ service.id }}: // {{ service.name }}
		return {{ service.name }}::getMessageParser(data);
%% endfor
	default:
		return { 0, nullptr };
	}
};


} // namespace MessageParser
} // namespace generated
} // namespace awap

#endif // GENERATED_MESSAGE_PARSER_HPP
